/**
 * Practical Exploit Test
 * 
 * This test attempts to ACTUALLY EXPLOIT the identified weaknesses:
 * 1. Near-Collision: Can we find inputs that produce very similar hashes?
 * 2. Weak Keys: Do the weak patterns lead to predictable/exploitable hashes?
 * 3. Linear Bias: Can we predict output bits from input bits?
 * 
 * The goal is to determine if these are THEORETICAL concerns or PRACTICAL vulnerabilities.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <stdint.h>
#include <math.h>
#include "../../Defines.h"
#include "../../InitializationPhase.h"
#include "../../ProcessingPhase.h"
#include "../../Calculations.h"
#include "../../util.h"

unsigned long numberOfRounds = 10000;
int hashLengthInBits = 128;

extern Tile_t field[FIELD_SIZE][FIELD_SIZE];
extern Position_t pos;

// ============================================================
// Helper Functions
// ============================================================

int popcount64(uint64_t x) {
    int count = 0;
    while (x) {
        count += x & 1;
        x >>= 1;
    }
    return count;
}

int hamming_distance_hex(const char* h1, const char* h2) {
    int dist = 0;
    size_t len = strlen(h1) < strlen(h2) ? strlen(h1) : strlen(h2);
    for (size_t i = 0; i < len; i++) {
        int v1 = (h1[i] >= '0' && h1[i] <= '9') ? (h1[i] - '0') : (h1[i] - 'a' + 10);
        int v2 = (h2[i] >= '0' && h2[i] <= '9') ? (h2[i] - '0') : (h2[i] - 'a' + 10);
        int xord = v1 ^ v2;
        for (int b = 0; b < 4; b++) {
            if (xord & (1 << b)) dist++;
        }
    }
    return dist;
}

// ============================================================
// EXPLOIT 1: Near-Collision Attack
// Can we craft inputs that produce hashes differing in very few bits?
// ============================================================
void exploit_near_collision(unsigned long rounds) {
    numberOfRounds = rounds;
    
    printf("\n");
    printf("╔══════════════════════════════════════════════════════════════╗\n");
    printf("║  EXPLOIT 1: Near-Collision Attack                           ║\n");
    printf("║  Goal: Find two different inputs with < 10%% bit difference  ║\n");
    printf("╚══════════════════════════════════════════════════════════════╝\n\n");
    
    int num_samples = 5000;
    int best_distance = 128;
    char best_input1[33] = {0};
    char best_input2[33] = {0};
    char best_hash1[65] = {0};
    char best_hash2[65] = {0};
    
    // Strategy 1: Random search
    printf("[Strategy 1] Random pair search (%d pairs)...\n", num_samples);
    
    typedef struct {
        unsigned char input[16];
        char hash[33];
    } Sample;
    
    Sample* samples = malloc(num_samples * sizeof(Sample));
    
    for (int i = 0; i < num_samples; i++) {
        for (int j = 0; j < 16; j++) {
            samples[i].input[j] = (unsigned char)(rand() % 256);
        }
        
        initFieldWithDefaultNumbers(DEFAULT_MAX_PRIME_INDEX);
        processBuffer(samples[i].input, 16);
        char* hash = calculateHashValue();
        strncpy(samples[i].hash, hash, 32);
        samples[i].hash[32] = '\0';
        free(hash);
    }
    
    // Find closest pair
    for (int i = 0; i < num_samples; i++) {
        for (int j = i + 1; j < num_samples; j++) {
            int dist = hamming_distance_hex(samples[i].hash, samples[j].hash);
            if (dist < best_distance) {
                best_distance = dist;
                for (int k = 0; k < 16; k++) {
                    sprintf(best_input1 + k*2, "%02x", samples[i].input[k]);
                    sprintf(best_input2 + k*2, "%02x", samples[j].input[k]);
                }
                strcpy(best_hash1, samples[i].hash);
                strcpy(best_hash2, samples[j].hash);
            }
        }
        if ((i+1) % 1000 == 0) {
            printf("  Progress: %d/%d (best so far: %d bits)\n", i+1, num_samples, best_distance);
        }
    }
    
    free(samples);
    
    printf("\n  Best near-collision found:\n");
    printf("  Input 1: %s\n", best_input1);
    printf("  Hash 1:  %s\n", best_hash1);
    printf("  Input 2: %s\n", best_input2);
    printf("  Hash 2:  %s\n", best_hash2);
    printf("  Hamming distance: %d / 128 bits (%.1f%%)\n", best_distance, best_distance * 100.0 / 128);
    
    // Strategy 2: Targeted search with similar inputs
    printf("\n[Strategy 2] Similar input search...\n");
    
    int targeted_best = 128;
    unsigned char base[16];
    for (int i = 0; i < 16; i++) base[i] = (unsigned char)(rand() % 256);
    
    initFieldWithDefaultNumbers(DEFAULT_MAX_PRIME_INDEX);
    processBuffer(base, 16);
    char* base_hash = calculateHashValue();
    
    // Try many small modifications
    for (int attempts = 0; attempts < 10000; attempts++) {
        unsigned char modified[16];
        memcpy(modified, base, 16);
        
        // Make 1-3 random byte changes
        int num_changes = 1 + (rand() % 3);
        for (int c = 0; c < num_changes; c++) {
            int pos = rand() % 16;
            modified[pos] = (unsigned char)(rand() % 256);
        }
        
        initFieldWithDefaultNumbers(DEFAULT_MAX_PRIME_INDEX);
        processBuffer(modified, 16);
        char* mod_hash = calculateHashValue();
        
        int dist = hamming_distance_hex(base_hash, mod_hash);
        if (dist < targeted_best) {
            targeted_best = dist;
        }
        
        free(mod_hash);
    }
    
    printf("  Best distance with similar inputs: %d / 128 bits\n", targeted_best);
    free(base_hash);
    
    // Verdict
    printf("\n  ═══════════════════════════════════════════════════════════\n");
    if (best_distance < 13) {  // Less than 10% of 128 bits
        printf("  ⚠️  EXPLOITABLE: Found near-collision with < 10%% difference!\n");
        printf("      This could weaken collision resistance significantly.\n");
    } else if (best_distance < 26) {  // Less than 20%
        printf("  ⚠️  MARGINAL: Near-collisions found with 10-20%% difference.\n");
        printf("      Theoretical concern but hard to exploit in practice.\n");
    } else {
        printf("  ✓  SECURE: No exploitable near-collisions found.\n");
        printf("      Minimum distance %d bits is acceptable.\n", best_distance);
    }
    printf("  ═══════════════════════════════════════════════════════════\n");
}

// ============================================================
// EXPLOIT 2: Weak Key Exploitation
// Can we use weak input patterns to create predictable hashes?
// ============================================================
void exploit_weak_keys(unsigned long rounds) {
    numberOfRounds = rounds;
    
    printf("\n");
    printf("╔══════════════════════════════════════════════════════════════╗\n");
    printf("║  EXPLOIT 2: Weak Key Exploitation                           ║\n");
    printf("║  Goal: Find patterns in hashes of weak inputs               ║\n");
    printf("╚══════════════════════════════════════════════════════════════╝\n\n");
    
    // Test if weak inputs produce distinguishable hashes
    unsigned char zero_input[32] = {0};
    unsigned char ones_input[32];
    memset(ones_input, 0xFF, 32);
    unsigned char alt_input[32];
    for (int i = 0; i < 32; i++) alt_input[i] = 0x55;  // 01010101
    
    initFieldWithDefaultNumbers(DEFAULT_MAX_PRIME_INDEX);
    processBuffer(zero_input, 32);
    char* zero_hash = calculateHashValue();
    
    initFieldWithDefaultNumbers(DEFAULT_MAX_PRIME_INDEX);
    processBuffer(ones_input, 32);
    char* ones_hash = calculateHashValue();
    
    initFieldWithDefaultNumbers(DEFAULT_MAX_PRIME_INDEX);
    processBuffer(alt_input, 32);
    char* alt_hash = calculateHashValue();
    
    printf("[Test 1] Weak input hash analysis:\n");
    printf("  Zero input hash:        %s\n", zero_hash);
    printf("  All-ones input hash:    %s\n", ones_hash);
    printf("  Alternating input hash: %s\n", alt_hash);
    
    // Check for patterns in weak hashes
    int zero_ones_dist = hamming_distance_hex(zero_hash, ones_hash);
    int zero_alt_dist = hamming_distance_hex(zero_hash, alt_hash);
    int ones_alt_dist = hamming_distance_hex(ones_hash, alt_hash);
    
    printf("\n  Distances between weak input hashes:\n");
    printf("  Zero vs Ones:        %d bits (expected: ~64)\n", zero_ones_dist);
    printf("  Zero vs Alternating: %d bits (expected: ~64)\n", zero_alt_dist);
    printf("  Ones vs Alternating: %d bits (expected: ~64)\n", ones_alt_dist);
    
    // Check if weak inputs are distinguishable from random
    printf("\n[Test 2] Distinguishing weak from random hashes...\n");
    
    // Generate random input hashes
    int matches_weak_pattern = 0;
    for (int i = 0; i < 1000; i++) {
        unsigned char random[32];
        for (int j = 0; j < 32; j++) random[j] = (unsigned char)(rand() % 256);
        
        initFieldWithDefaultNumbers(DEFAULT_MAX_PRIME_INDEX);
        processBuffer(random, 32);
        char* random_hash = calculateHashValue();
        
        // Check if random hash is closer to weak hashes than expected
        int dist_to_zero = hamming_distance_hex(random_hash, zero_hash);
        if (dist_to_zero < 32) {  // Very close to weak hash
            matches_weak_pattern++;
        }
        
        free(random_hash);
    }
    
    printf("  Random hashes very close to zero-hash: %d / 1000\n", matches_weak_pattern);
    
    // Test: Can we distinguish weak key hashes statistically?
    printf("\n[Test 3] Statistical distinguisher test...\n");
    
    // Count leading zeros in weak vs random hashes
    int weak_leading_zeros = 0;
    int random_leading_zeros = 0;
    
    for (int i = 0; i < 100; i++) {
        // Weak inputs (variations of zero/one patterns)
        unsigned char weak[32];
        memset(weak, i % 2 == 0 ? 0x00 : 0xFF, 32);
        
        initFieldWithDefaultNumbers(DEFAULT_MAX_PRIME_INDEX);
        processBuffer(weak, 32);
        char* whash = calculateHashValue();
        
        if (whash[0] == '0') weak_leading_zeros++;
        free(whash);
        
        // Random inputs
        unsigned char random[32];
        for (int j = 0; j < 32; j++) random[j] = (unsigned char)(rand() % 256);
        
        initFieldWithDefaultNumbers(DEFAULT_MAX_PRIME_INDEX);
        processBuffer(random, 32);
        char* rhash = calculateHashValue();
        
        if (rhash[0] == '0') random_leading_zeros++;
        free(rhash);
    }
    
    printf("  Leading '0' in weak hashes:   %d%% (expected: 6.25%%)\n", weak_leading_zeros);
    printf("  Leading '0' in random hashes: %d%% (expected: 6.25%%)\n", random_leading_zeros);
    
    free(zero_hash);
    free(ones_hash);
    free(alt_hash);
    
    // Verdict
    printf("\n  ═══════════════════════════════════════════════════════════\n");
    int avg_dist = (zero_ones_dist + zero_alt_dist + ones_alt_dist) / 3;
    if (avg_dist < 50 || matches_weak_pattern > 10) {
        printf("  ⚠️  EXPLOITABLE: Weak keys produce distinguishable hashes!\n");
    } else {
        printf("  ✓  NOT EXPLOITABLE: Weak keys don't create practical vulnerability.\n");
        printf("      Distances are normal, no statistical distinguisher found.\n");
    }
    printf("  ═══════════════════════════════════════════════════════════\n");
}

// ============================================================
// EXPLOIT 3: Linear Bias Exploitation  
// Can we predict output bits from input bits?
// ============================================================
void exploit_linear_bias(unsigned long rounds) {
    numberOfRounds = rounds;
    
    printf("\n");
    printf("╔══════════════════════════════════════════════════════════════╗\n");
    printf("║  EXPLOIT 3: Linear Bias Exploitation                        ║\n");
    printf("║  Goal: Predict output bits with > 60%% accuracy              ║\n");
    printf("╚══════════════════════════════════════════════════════════════╝\n\n");
    
    printf("[Training Phase] Learning linear relationships...\n");
    
    // Try to learn a linear predictor for each output bit
    int num_training = 1000;
    int num_test = 500;
    
    // Store training data
    typedef struct {
        int input_bits[128];   // First 16 bytes = 128 bits
        int output_bits[128];  // First 32 hex chars = 128 bits
    } DataPoint;
    
    DataPoint* training = malloc(num_training * sizeof(DataPoint));
    DataPoint* test = malloc(num_test * sizeof(DataPoint));
    
    // Generate training data
    for (int i = 0; i < num_training + num_test; i++) {
        unsigned char input[16];
        for (int j = 0; j < 16; j++) input[j] = (unsigned char)(rand() % 256);
        
        initFieldWithDefaultNumbers(DEFAULT_MAX_PRIME_INDEX);
        processBuffer(input, 16);
        char* hash = calculateHashValue();
        
        DataPoint* dp = (i < num_training) ? &training[i] : &test[i - num_training];
        
        // Extract input bits
        for (int j = 0; j < 128; j++) {
            dp->input_bits[j] = (input[j/8] >> (j%8)) & 1;
        }
        
        // Extract output bits
        for (int j = 0; j < 128 && j/4 < (int)strlen(hash); j++) {
            int nibble_idx = j / 4;
            int bit_in_nibble = 3 - (j % 4);
            int nibble = (hash[nibble_idx] >= '0' && hash[nibble_idx] <= '9') 
                         ? (hash[nibble_idx] - '0') 
                         : (hash[nibble_idx] - 'a' + 10);
            dp->output_bits[j] = (nibble >> bit_in_nibble) & 1;
        }
        
        free(hash);
    }
    
    // For each output bit, find the best single-bit linear predictor
    printf("[Analysis] Finding best linear predictors...\n");
    
    int best_accuracy = 50;
    int best_out_bit = -1;
    int best_in_bit = -1;
    
    for (int out = 0; out < 64; out++) {  // Test first 64 output bits
        for (int in = 0; in < 64; in++) {  // Against first 64 input bits
            int correct = 0;
            for (int i = 0; i < num_training; i++) {
                if (training[i].input_bits[in] == training[i].output_bits[out]) {
                    correct++;
                }
            }
            
            int accuracy = (correct * 100) / num_training;
            // Also check inverse correlation
            int inv_accuracy = 100 - accuracy;
            
            if (accuracy > best_accuracy || inv_accuracy > best_accuracy) {
                best_accuracy = accuracy > inv_accuracy ? accuracy : inv_accuracy;
                best_out_bit = out;
                best_in_bit = in;
            }
        }
    }
    
    printf("  Best linear predictor: input bit %d -> output bit %d\n", 
           best_in_bit, best_out_bit);
    printf("  Training accuracy: %d%%\n", best_accuracy);
    
    // Test the predictor
    printf("\n[Testing Phase] Validating on unseen data...\n");
    
    int test_correct = 0;
    int use_inverse = 0;
    
    // Determine if we should use direct or inverse correlation
    int train_direct = 0;
    for (int i = 0; i < num_training; i++) {
        if (training[i].input_bits[best_in_bit] == training[i].output_bits[best_out_bit]) {
            train_direct++;
        }
    }
    use_inverse = (train_direct < num_training / 2);
    
    for (int i = 0; i < num_test; i++) {
        int predicted = use_inverse ? 
                        (1 - test[i].input_bits[best_in_bit]) : 
                        test[i].input_bits[best_in_bit];
        if (predicted == test[i].output_bits[best_out_bit]) {
            test_correct++;
        }
    }
    
    int test_accuracy = (test_correct * 100) / num_test;
    printf("  Test accuracy: %d%% (expected for random: 50%%)\n", test_accuracy);
    
    free(training);
    free(test);
    
    // Verdict
    printf("\n  ═══════════════════════════════════════════════════════════\n");
    if (test_accuracy >= 60) {
        printf("  ⚠️  EXPLOITABLE: Can predict output bits with %d%% accuracy!\n", test_accuracy);
        printf("      Linear cryptanalysis could be effective.\n");
    } else if (test_accuracy >= 55) {
        printf("  ⚠️  MARGINAL: Slight bias detected (%d%% accuracy).\n", test_accuracy);
        printf("      Would need many samples to exploit.\n");
    } else {
        printf("  ✓  NOT EXPLOITABLE: No practical linear bias found.\n");
        printf("      Test accuracy %d%% is within random noise.\n", test_accuracy);
    }
    printf("  ═══════════════════════════════════════════════════════════\n");
}

// ============================================================
// EXPLOIT 4: Birthday Attack Practical Test
// How many hashes do we need to find a collision?
// ============================================================
void exploit_birthday(unsigned long rounds) {
    numberOfRounds = rounds;
    
    printf("\n");
    printf("╔══════════════════════════════════════════════════════════════╗\n");
    printf("║  EXPLOIT 4: Practical Birthday Attack                       ║\n");
    printf("║  Goal: Find actual collision or near-collision              ║\n");
    printf("╚══════════════════════════════════════════════════════════════╝\n\n");
    
    // For 128-bit hash, birthday bound is 2^64 ~ 1.8 * 10^19
    // We can't test that many, so we test truncated versions
    
    printf("[Test 1] Looking for collisions in first 32 bits...\n");
    
    int num_hashes = 100000;  // Birthday bound for 32 bits is ~65,000
    
    typedef struct {
        uint32_t hash32;
        int index;
    } Hash32;
    
    Hash32* hashes = malloc(num_hashes * sizeof(Hash32));
    
    for (int i = 0; i < num_hashes; i++) {
        unsigned char input[16];
        for (int j = 0; j < 16; j++) input[j] = (unsigned char)(rand() % 256);
        
        // Store input index in the input itself for later retrieval
        input[0] = (unsigned char)(i & 0xFF);
        input[1] = (unsigned char)((i >> 8) & 0xFF);
        input[2] = (unsigned char)((i >> 16) & 0xFF);
        
        initFieldWithDefaultNumbers(DEFAULT_MAX_PRIME_INDEX);
        processBuffer(input, 16);
        char* hash = calculateHashValue();
        
        // Extract first 32 bits (8 hex chars)
        uint32_t h32 = 0;
        for (int j = 0; j < 8 && hash[j]; j++) {
            int nibble = (hash[j] >= '0' && hash[j] <= '9') 
                         ? (hash[j] - '0') 
                         : (hash[j] - 'a' + 10);
            h32 = (h32 << 4) | nibble;
        }
        
        hashes[i].hash32 = h32;
        hashes[i].index = i;
        
        free(hash);
        
        if ((i+1) % 20000 == 0) {
            printf("  Generated %d hashes...\n", i+1);
        }
    }
    
    // Sort and find collisions
    for (int i = 0; i < num_hashes - 1; i++) {
        for (int j = i + 1; j < num_hashes && j < i + 1000; j++) {
            if (hashes[i].hash32 == hashes[j].hash32 && hashes[i].index != hashes[j].index) {
                printf("\n  ⚠️  32-BIT COLLISION FOUND!\n");
                printf("      Index %d and %d produce same 32-bit prefix\n", 
                       hashes[i].index, hashes[j].index);
                // Continue to count total collisions
            }
        }
    }
    
    // Count 32-bit collisions with sorting
    int collision_count = 0;
    // Simple O(n^2) for small subset check
    for (int i = 0; i < 10000; i++) {
        for (int j = i + 1; j < 10000; j++) {
            if (hashes[i].hash32 == hashes[j].hash32) {
                collision_count++;
            }
        }
    }
    
    printf("  32-bit collisions in first 10k hashes: %d\n", collision_count);
    printf("  Expected for ideal hash: ~1.2 (birthday probability)\n");
    
    free(hashes);
    
    // Verdict
    printf("\n  ═══════════════════════════════════════════════════════════\n");
    if (collision_count > 5) {
        printf("  ⚠️  CONCERNING: More 32-bit collisions than expected.\n");
    } else {
        printf("  ✓  NORMAL: 32-bit collision rate is within expectations.\n");
        printf("      Full 128-bit collision would require ~2^64 operations.\n");
    }
    printf("  ═══════════════════════════════════════════════════════════\n");
}

// ============================================================
// Main
// ============================================================
int main(void) {
    printf("╔══════════════════════════════════════════════════════════════╗\n");
    printf("║           PRACTICAL EXPLOIT TEST SUITE                       ║\n");
    printf("║  Testing if identified weaknesses are actually exploitable  ║\n");
    printf("╚══════════════════════════════════════════════════════════════╝\n");
    
    srand((unsigned)time(NULL));
    
    unsigned long rounds = 10000;
    
    printf("\nConfiguration:\n");
    printf("  Rounds: %lu\n", rounds);
    printf("  Hash size: 128 bits\n");
    printf("  This test will take several minutes...\n");
    
    // Run all exploit tests
    exploit_near_collision(rounds);
    exploit_weak_keys(rounds);
    exploit_linear_bias(rounds);
    exploit_birthday(rounds);
    
    // Final summary
    printf("\n");
    printf("╔══════════════════════════════════════════════════════════════╗\n");
    printf("║                    FINAL ASSESSMENT                          ║\n");
    printf("╚══════════════════════════════════════════════════════════════╝\n");
    printf("\n");
    printf("Summary of exploit attempts:\n");
    printf("  1. Near-Collision:  See results above\n");
    printf("  2. Weak Keys:       See results above\n");
    printf("  3. Linear Bias:     See results above\n");
    printf("  4. Birthday Attack: See results above\n");
    printf("\n");
    printf("If all tests show 'NOT EXPLOITABLE' or 'NORMAL':\n");
    printf("  -> The theoretical weaknesses are NOT practically exploitable\n");
    printf("  -> The hash is suitable for most applications\n");
    printf("\n");
    printf("If any test shows 'EXPLOITABLE' or 'CONCERNING':\n");
    printf("  -> There is a real vulnerability that should be addressed\n");
    printf("  -> Consider the specific attack scenario for your use case\n");
    printf("\n");
    
    return 0;
}
