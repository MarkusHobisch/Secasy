/*
 * SAC Weakness Exploitation Test
 * 
 * Attempts to exploit the 38% SAC acceptance rate by:
 * 1. Finding specific input-bit -> output-bit correlations
 * 2. Using those correlations to predict partial hash values
 * 3. Testing if weak bit pairs can be exploited for distinguishing attacks
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <math.h>

#include "../../Defines.h"
#include "../../InitializationPhase.h"
#include "../../ProcessingPhase.h"

unsigned long numberOfRounds = 500;
int numberOfBits = 256;

char* compute_hash(const unsigned char* data, size_t len, int maxPrimeIndex) {
    initFieldWithDefaultNumbers(maxPrimeIndex);
    processBuffer(data, len);
    return calculateHashValue();
}

// Convert hex char to bits
void hex_to_bits(const char* hex, int* bits, int max_bits) {
    int bit_idx = 0;
    for (int i = 0; hex[i] && bit_idx < max_bits; i++) {
        int v = (hex[i] >= 'a') ? (hex[i] - 'a' + 10) : 
                (hex[i] >= 'A') ? (hex[i] - 'A' + 10) : (hex[i] - '0');
        for (int b = 3; b >= 0 && bit_idx < max_bits; b--) {
            bits[bit_idx++] = (v >> b) & 1;
        }
    }
}

int main(int argc, char* argv[]) {
    printf("===========================================\n");
    printf("SAC Weakness Exploitation Test\n");
    printf("===========================================\n\n");
    
    int maxPrimeIndex = 200;
    int inputLen = 8;
    int trials = 1000;
    
    if (argc > 1) trials = atoi(argv[1]);
    
    int inputBits = inputLen * 8;
    int outputBits = 256; // Assuming 256-bit hash
    
    // Track flip probabilities for each input-bit -> output-bit pair
    // We'll sample a subset due to memory constraints
    int sampleOutputBits = 64; // First 64 output bits
    
    int** flipCounts = malloc(inputBits * sizeof(int*));
    for (int i = 0; i < inputBits; i++) {
        flipCounts[i] = calloc(sampleOutputBits, sizeof(int));
    }
    
    printf("Configuration:\n");
    printf("  Trials: %d\n", trials);
    printf("  Input length: %d bytes (%d bits)\n", inputLen, inputBits);
    printf("  Output bits sampled: %d\n", sampleOutputBits);
    printf("  Max Prime Index: %d\n", maxPrimeIndex);
    printf("  Rounds: %lu\n\n", numberOfRounds);
    
    srand(12345);
    unsigned char* input = malloc(inputLen);
    int* baseBits = malloc(sampleOutputBits * sizeof(int));
    int* flipBits = malloc(sampleOutputBits * sizeof(int));
    
    printf("Collecting SAC statistics...\n");
    
    for (int t = 0; t < trials; t++) {
        if (t % 100 == 0) {
            printf("\r  Trial %d/%d", t, trials);
            fflush(stdout);
        }
        
        // Generate random input
        for (int i = 0; i < inputLen; i++) {
            input[i] = rand() & 0xFF;
        }
        
        // Get base hash
        char* baseHash = compute_hash(input, inputLen, maxPrimeIndex);
        hex_to_bits(baseHash, baseBits, sampleOutputBits);
        free(baseHash);
        
        // Flip each input bit and measure output changes
        for (int inBit = 0; inBit < inputBits; inBit++) {
            int bytePos = inBit / 8;
            int bitPos = inBit % 8;
            
            input[bytePos] ^= (1 << bitPos);
            
            char* flipHash = compute_hash(input, inputLen, maxPrimeIndex);
            hex_to_bits(flipHash, flipBits, sampleOutputBits);
            free(flipHash);
            
            // Count which output bits flipped
            for (int outBit = 0; outBit < sampleOutputBits; outBit++) {
                if (baseBits[outBit] != flipBits[outBit]) {
                    flipCounts[inBit][outBit]++;
                }
            }
            
            // Restore input
            input[bytePos] ^= (1 << bitPos);
        }
    }
    
    printf("\r  Completed %d trials\n\n", trials);
    
    // Analyze results - find weak and strong correlations
    printf("=== SAC Analysis Results ===\n\n");
    
    int weakPairs = 0;
    int strongPairs = 0;
    int totalPairs = inputBits * sampleOutputBits;
    
    double minProb = 1.0, maxProb = 0.0;
    int minIn = 0, minOut = 0, maxIn = 0, maxOut = 0;
    
    double sumProb = 0;
    int acceptedPairs = 0; // Pairs within [0.48, 0.52]
    
    for (int inBit = 0; inBit < inputBits; inBit++) {
        for (int outBit = 0; outBit < sampleOutputBits; outBit++) {
            double prob = (double)flipCounts[inBit][outBit] / trials;
            sumProb += prob;
            
            if (prob >= 0.48 && prob <= 0.52) {
                acceptedPairs++;
            }
            
            if (prob < 0.40 || prob > 0.60) weakPairs++;
            if (prob < 0.35 || prob > 0.65) strongPairs++;
            
            if (prob < minProb) { minProb = prob; minIn = inBit; minOut = outBit; }
            if (prob > maxProb) { maxProb = prob; maxIn = inBit; maxOut = outBit; }
        }
    }
    
    double meanProb = sumProb / totalPairs;
    double acceptanceRate = 100.0 * acceptedPairs / totalPairs;
    
    printf("Overall Statistics:\n");
    printf("  Total bit pairs analyzed: %d\n", totalPairs);
    printf("  Mean flip probability: %.4f (ideal: 0.5)\n", meanProb);
    printf("  SAC Acceptance Rate: %.2f%% (target: >=95%%)\n", acceptanceRate);
    printf("  Min probability: %.4f (input bit %d -> output bit %d)\n", minProb, minIn, minOut);
    printf("  Max probability: %.4f (input bit %d -> output bit %d)\n", maxProb, maxIn, maxOut);
    printf("  Weak pairs (outside [0.40, 0.60]): %d (%.2f%%)\n", weakPairs, 100.0 * weakPairs / totalPairs);
    printf("  Strong deviations (outside [0.35, 0.65]): %d (%.2f%%)\n", strongPairs, 100.0 * strongPairs / totalPairs);
    
    // Find top 10 most biased pairs
    printf("\n=== Top 10 Most Biased Bit Pairs ===\n");
    
    typedef struct { int inBit; int outBit; double prob; double bias; } BiasedPair;
    BiasedPair* allPairs = malloc(totalPairs * sizeof(BiasedPair));
    
    int idx = 0;
    for (int inBit = 0; inBit < inputBits; inBit++) {
        for (int outBit = 0; outBit < sampleOutputBits; outBit++) {
            double prob = (double)flipCounts[inBit][outBit] / trials;
            allPairs[idx].inBit = inBit;
            allPairs[idx].outBit = outBit;
            allPairs[idx].prob = prob;
            allPairs[idx].bias = fabs(prob - 0.5);
            idx++;
        }
    }
    
    // Simple bubble sort for top 10
    for (int i = 0; i < 10; i++) {
        for (int j = i + 1; j < totalPairs; j++) {
            if (allPairs[j].bias > allPairs[i].bias) {
                BiasedPair tmp = allPairs[i];
                allPairs[i] = allPairs[j];
                allPairs[j] = tmp;
            }
        }
    }
    
    printf("  Rank  InputBit  OutputBit  FlipProb  Bias\n");
    for (int i = 0; i < 10; i++) {
        printf("  %2d    %3d       %3d        %.4f    %.4f\n", 
               i+1, allPairs[i].inBit, allPairs[i].outBit, 
               allPairs[i].prob, allPairs[i].bias);
    }
    
    // Exploitation attempt: Can we predict output bits?
    printf("\n=== Exploitation Test ===\n");
    printf("Testing if biased pairs can be exploited for prediction...\n\n");
    
    int testTrials = 100;
    int correctPredictions = 0;
    int totalPredictions = 0;
    
    // Use the most biased pair
    int targetInBit = allPairs[0].inBit;
    int targetOutBit = allPairs[0].outBit;
    double targetProb = allPairs[0].prob;
    
    printf("Using most biased pair: input bit %d -> output bit %d (prob=%.4f)\n", 
           targetInBit, targetOutBit, targetProb);
    
    for (int t = 0; t < testTrials; t++) {
        // Generate random input
        for (int i = 0; i < inputLen; i++) {
            input[i] = rand() & 0xFF;
        }
        
        // Get base hash
        char* baseHash = compute_hash(input, inputLen, maxPrimeIndex);
        hex_to_bits(baseHash, baseBits, sampleOutputBits);
        int baseOutBitValue = baseBits[targetOutBit];
        free(baseHash);
        
        // Flip target input bit
        int bytePos = targetInBit / 8;
        int bitPos = targetInBit % 8;
        input[bytePos] ^= (1 << bitPos);
        
        char* flipHash = compute_hash(input, inputLen, maxPrimeIndex);
        hex_to_bits(flipHash, flipBits, sampleOutputBits);
        int flipOutBitValue = flipBits[targetOutBit];
        free(flipHash);
        
        // Predict: if prob > 0.5, expect flip; if prob < 0.5, expect no flip
        int predictFlip = (targetProb > 0.5) ? 1 : 0;
        int actualFlip = (baseOutBitValue != flipOutBitValue) ? 1 : 0;
        
        if (predictFlip == actualFlip) correctPredictions++;
        totalPredictions++;
    }
    
    double predictionAccuracy = 100.0 * correctPredictions / totalPredictions;
    
    printf("Prediction results:\n");
    printf("  Correct predictions: %d / %d (%.2f%%)\n", 
           correctPredictions, totalPredictions, predictionAccuracy);
    printf("  Random baseline: 50.00%%\n");
    printf("  Advantage over random: %.2f%%\n", predictionAccuracy - 50.0);
    
    if (predictionAccuracy > 55) {
        printf("\n⚠ WARNING: Exploitable bias detected! Prediction accuracy significantly above random.\n");
    } else {
        printf("\n✓ No practically exploitable bias found.\n");
    }
    
    // Cleanup
    free(input);
    free(baseBits);
    free(flipBits);
    free(allPairs);
    for (int i = 0; i < inputBits; i++) free(flipCounts[i]);
    free(flipCounts);
    
    printf("\n===========================================\n");
    printf("Test Complete\n");
    printf("===========================================\n");
    
    return 0;
}
